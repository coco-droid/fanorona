# Syst√®me UI DOM-like - Documentation

## üéØ Vue d'ensemble

Le nouveau syst√®me UI de Fanorona offre une syntaxe **DOM-like** similaire √† JavaScript, permettant de cr√©er et manipuler des interfaces utilisateur de mani√®re intuitive.

**üÜï Nouvelles fonctionnalit√©s :**
- ‚úÖ **Logs de tra√ßage des √©v√©nements** pour debugging avanc√©
- ‚úÖ **Z-index implicites** calcul√©s automatiquement
- ‚úÖ **Support complet des images PNG** pour les backgrounds
- ‚úÖ **Correction de l'affichage du texte** sur tous les composants

## üì¶ Architecture Container Modulaire - NOUVEAU ! 

### üéØ Containers avec sections sp√©cialis√©es

La nouvelle architecture divise les containers en **3 sections sp√©cialis√©es** :

```c
// Container principal avec sections automatiques
UINode* modal = UI_CONTAINER_CENTERED(tree, "game-menu", 500, 400);

// Architecture cr√©√©e automatiquement :
// ‚îå‚îÄ‚îÄ‚îÄ Container Principal (flexbox column) ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ Section Logo (400x100) ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
// ‚îÇ  ‚îÇ     Logo centr√©               ‚îÇ         ‚îÇ
// ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
// ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ Section Sous-titre (400x50) ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
// ‚îÇ  ‚îÇ     "Strat√©gie et Tradition"      ‚îÇ   ‚îÇ
// ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
// ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ Section Contenu (450x250) ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
// ‚îÇ  ‚îÇ     Vos boutons/contenu         ‚îÇ     ‚îÇ
// ‚îÇ  ‚îÇ     (centr√© automatiquement)    ‚îÇ     ‚îÇ
// ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ‚ú® Avantages de cette architecture

1. **üéØ Centrage automatique** : Chaque section centre son contenu
2. **üìè Tailles d√©di√©es** : Chaque section a sa taille optimis√©e
3. **üîß Sans margin/padding** : Plus besoin de calculs complexes
4. **üé® Flexbox natif** : Utilisation pure de CSS Flexbox
5. **üì¶ Modulaire** : Chaque section est ind√©pendante

### üöÄ Utilisation simplifi√©e

```c
// 1. Cr√©er le container (logo et sous-titre automatiques)
UINode* dialog = UI_CONTAINER_CENTERED(tree, "my-dialog", 500, 400);

// 2. Ajouter votre contenu (sera centr√© automatiquement)
UINode* button_group = UI_DIV(tree, "buttons");
ui_set_display_flex(button_group);
FLEX_COLUMN(button_group);
ui_set_flex_gap(button_group, 15);

// Ajouter des boutons au groupe
UINode* play = ui_button(tree, "play", "JOUER", on_play, NULL);
UINode* quit = ui_button(tree, "quit", "QUITTER", on_quit, NULL);
APPEND(button_group, play);
APPEND(button_group, quit);

// 3. Le contenu va dans la section d√©di√©e (centr√© automatiquement)
ui_container_add_content(dialog, button_group);

// R√©sultat : Interface parfaitement centr√©e sans calculs manuels !
```

### üîÑ Migration depuis l'ancien syst√®me

```c
// ANCIEN (calculs manuels) :
ui_set_position(logo, calculated_x, 23);
ui_set_position(subtitle, calculated_x, 111);
atomic_set_margin(subtitle, 0, 0, 20, 0);
// ... calculs complexes de positions ...

// NOUVEAU (automatique) :
UINode* container = UI_CONTAINER_CENTERED(tree, "dialog", 500, 400);
ui_container_add_content(container, my_buttons);
// Logo et sous-titre positionn√©s automatiquement !
// Boutons centr√©s automatiquement dans leur section !
```

## üîç Syst√®me de logs pour debugging

### Activation et utilisation

```c
// Activer les logs d'√©v√©nements (maintenant plus discrets)
ui_set_event_logging(true);

// Les logs critiques apparaissent toujours :
// [EVENT] [UIComponent] [Click] [save-btn] : Button click callback triggered
// [EVENT] [Button] [StateChange] [save-btn] : State NORMAL -> PRESSED

// üîß AM√âLIORATION : Logs verbeux supprim√©s pour une console plus propre
// ‚ùå Plus de logs de mouvement souris en continu
// ‚ùå Plus de logs de hit testing d√©taill√©s  
// ‚ùå Plus de logs de rendu p√©riodiques
```

### Logs personnalis√©s

```c
// Ajouter vos propres logs (toujours disponible)
ui_log_event("MyComponent", "CustomEvent", "my-element", "Mon message personnalis√©");
```

**üìä Console all√©g√©e** :
- ‚úÖ √âv√©nements utilisateur importants (clics boutons)
- ‚úÖ Changements d'√©tat visuels
- ‚úÖ Erreurs et avertissements
- ‚ùå Mouvements souris r√©p√©titifs supprim√©s
- ‚ùå Logs de synchronisation technique supprim√©s

## üéØ Z-Index automatique

### Gestion intelligente

```c
// Les z-index sont calcul√©s automatiquement dans l'ordre d'ajout
UINode* background = ui_div(tree, "bg");      // z-index automatique: 1
UINode* content = ui_div(tree, "content");    // z-index automatique: 2
UINode* overlay = ui_div(tree, "overlay");    // z-index automatique: 3

// Calculer apr√®s construction de l'interface
ui_calculate_implicit_z_index(tree);

// Z-index explicite prioritaire
ui_set_z_index(overlay, 100); // Sera au-dessus de tous les autres
```

### Inspection des z-index

```c
// V√©rifier le z-index effectif (explicite ou calcul√©)
int effective_z = ui_node_get_effective_z_index(element);
printf("Z-index de %s : %d\n", element->id, effective_z);
```

## üé® Images PNG avanc√©es

### Background images optimis√©es

```c
// Utiliser des images PNG comme fond
ui_set_background_image(element, "assets/my_background.png");

// Pour les boutons sp√©cifiquement
ui_button_set_background_image(button, "assets/button_bg.png");

// L'image sera automatiquement :
// - Charg√©e en m√©moire
// - Redimensionn√©e √† la taille de l'√©l√©ment
// - Rendue avec transparence pr√©serv√©e
```

### Correction des artefacts de texte

```c
// Corriger les probl√®mes d'affichage de texte sur PNG
ui_button_fix_text_rendering(button);

// Cette fonction r√©sout :
// - Les carr√©s gris autour du texte
// - Le positionnement incorrect
// - Les probl√®mes de contraste
```

## üé® Feedback visuel interactif

### Boutons avec √©tats visuels

```c
// Cr√©er des boutons avec feedback automatique
UINode* confirm_btn = ui_button(tree, "confirm", "CONFIRMER", on_confirm, NULL);
ui_button_set_background_image(confirm_btn, "btn_confirm.png");

// √âtats visuels automatiques :
// HOVER: Agrandissement (+2px) + overlay blanc translucide
// CLICK: R√©duction (-4px) + fond vert + texte noir
// NORMAL: Taille normale + fond transparent + texte blanc

// Connexion des √©v√©nements avec feedback
atomic_set_click_handler(confirm_btn->element, confirm_clicked);
atomic_set_hover_handler(confirm_btn->element, button_hovered);
atomic_set_unhover_handler(confirm_btn->element, button_unhovered);
```

### Styles pr√©d√©finis pour feedback

```c
// Appliquer des styles contextuels instantan√©ment
BUTTON_SUCCESS(play_btn);    // Vert pour actions positives
BUTTON_DANGER(delete_btn);   // Rouge pour actions dangereuses
BUTTON_INFO(help_btn);       // Bleu pour informations
BUTTON_WARNING(reset_btn);   // Orange pour avertissements

// Contr√¥le manuel des √©tats
BUTTON_PRESSED(btn);         // Simuler un clic
BUTTON_HOVER_ON(btn);        // Simuler un survol
BUTTON_RESET(btn);           // Retour √† l'√©tat normal
```

### Logs de feedback en temps r√©el

```c
// Avec ui_set_event_logging(true), observez le feedback :

// Survol d'un bouton :
// [EVENT] [UIComponent] [VisualState] [confirm] : Button hover state applied
// [EVENT] [UserCallback] [ButtonHoverVisual] [home_scene.c] : button_hovered - VISUAL FEEDBACK: white overlay, size increased

// Clic sur un bouton :
// [EVENT] [UIComponent] [VisualState] [confirm] : Button pressed state applied  
// [EVENT] [UserCallback] [ConfirmButtonVisual] [home_scene.c] : confirm_button_clicked - VISUAL FEEDBACK APPLIED: green bg, black text, size reduced
// [EVENT] [UIComponent] [VisualStyle] [confirm] : Success style applied (green)

// Restauration automatique :
// [EVENT] [UIComponent] [VisualState] [confirm] : Button normal state restored from hover
```

## üí° Exemple d'interface moderne

```c
#include "src/ui/ui_components.h"

void create_game_menu() {
    // === SETUP INITIAL ===
    ui_set_event_logging(true); // Debugging activ√©
    
    UITree* tree = ui_tree_create();
    ui_set_global_tree(tree);
    
    // === INTERFACE PRINCIPALE ===
    
    // Fond principal avec image
    UINode* app = UI_DIV(tree, "game-menu");
    SET_POS(app, 0, 0);
    SET_SIZE(app, 800, 600);
    ui_set_background_image(app, "menu_background.png");
    
    // Logo du jeu
    UINode* logo = UI_IMAGE(tree, "logo", logo_texture);
    SET_SIZE(logo, 400, 150);
    CENTER_X(logo);
    SET_POS(logo, logo->x, 50);
    
    // Container pour les boutons avec flexbox
    UINode* menu_buttons = UI_DIV(tree, "menu-buttons");
    SET_SIZE(menu_buttons, 300, 400);
    CENTER_X(menu_buttons);
    SET_POS(menu_buttons, menu_buttons->x, 220);
    ui_set_display_flex(menu_buttons);
    FLEX_COLUMN(menu_buttons);
    ui_set_justify_content(menu_buttons, "center");
    ui_set_align_items(menu_buttons, "center");
    ui_set_flex_gap(menu_buttons, 20);
    
    // Boutons avec images PNG personnalis√©es
    UINode* play_btn = ui_button(tree, "play", "NOUVELLE PARTIE", on_new_game, NULL);
    SET_SIZE(play_btn, 280, 60);
    ui_button_set_background_image(play_btn, "btn_play.png");
    ui_set_text_color(play_btn, "rgb(255,255,255)");
    ui_button_fix_text_rendering(play_btn);
    
    UINode* load_btn = ui_button(tree, "load", "CHARGER PARTIE", on_load_game, NULL);
    SET_SIZE(load_btn, 280, 60);
    ui_button_set_background_image(load_btn, "btn_load.png");
    ui_set_text_color(load_btn, "rgb(255,255,255)");
    ui_button_fix_text_rendering(load_btn);
    
    UINode* options_btn = ui_button(tree, "options", "OPTIONS", on_options, NULL);
    SET_SIZE(options_btn, 280, 60);
    ui_button_set_background_image(options_btn, "btn_options.png");
    ui_set_text_color(options_btn, "rgb(255,255,255)");
    ui_button_fix_text_rendering(options_btn);
    
    UINode* quit_btn = ui_button(tree, "quit", "QUITTER", on_quit, NULL);
    SET_SIZE(quit_btn, 280, 60);
    ui_button_set_background_image(quit_btn, "btn_quit.png");
    ui_set_text_color(quit_btn, "rgb(255,255,255)");
    ui_button_fix_text_rendering(quit_btn);
    
    // Popup de confirmation (z-index √©lev√©)
    UINode* confirm_popup = UI_DIV(tree, "confirm-popup");
    SET_SIZE(confirm_popup, 400, 200);
    CENTER(confirm_popup);
    ui_set_z_index(confirm_popup, 1000); // Au-dessus de tout
    ui_set_background_image(confirm_popup, "popup_bg.png");
    ui_node_set_style(confirm_popup, "display", "none"); // Cach√© par d√©faut
    
    // === CONSTRUCTION DE LA HI√âRARCHIE ===
    
    APPEND(tree->root, app);
    APPEND(app, logo);
    APPEND(app, menu_buttons);
    APPEND(menu_buttons, play_btn);
    APPEND(menu_buttons, load_btn);
    APPEND(menu_buttons, options_btn);
    APPEND(menu_buttons, quit_btn);
    APPEND(app, confirm_popup);
    
    // Calculer les z-index automatiques
    ui_calculate_implicit_z_index(tree);
    
    printf("‚úÖ Menu de jeu cr√©√© avec images PNG et z-index automatiques\n");
    
    // Les logs montreront :
    // [EVENT] [UIComponent] [ZIndexCalculation] [game-menu] : Implicit z-index set to 1
    // [EVENT] [UIComponent] [ZIndexCalculation] [logo] : Implicit z-index set to 2
    // [EVENT] [UIComponent] [ZIndexCalculation] [menu-buttons] : Implicit z-index set to 3
    // [EVENT] [UIComponent] [ZIndexCalculation] [play] : Implicit z-index set to 4
    // [EVENT] [UIComponent] [ZIndexCalculation] [load] : Implicit z-index set to 5
    // [EVENT] [UIComponent] [ZIndexCalculation] [options] : Implicit z-index set to 6
    // [EVENT] [UIComponent] [ZIndexCalculation] [quit] : Implicit z-index set to 7
    // [EVENT] [UIComponent] [ZIndexCalculation] [confirm-popup] : Explicit z-index 1000 kept
}

// Callbacks avec logs automatiques
void on_new_game(UINode* node, void* user_data) {
    // Les logs appara√Ætront automatiquement :
    // [EVENT] [EventManager] [MouseClick] [play] : Event received at (400, 280)
    // [EVENT] [AtomicElement] [MouseClick] [play] : Hit test passed
    // [EVENT] [UIComponent] [Click] [play] : Button click callback triggered
    
    printf("üéÆ Nouvelle partie d√©marr√©e\n");
    
    // Afficher popup de confirmation
    UINode* popup = $("#confirm-popup");
    ui_node_set_style(popup, "display", "block");
}

void on_quit(UINode* node, void* user_data) {
    // [EVENT] [Button] [StateChange] [quit] : State NORMAL -> PRESSED
    printf("üö™ Fermeture du jeu\n");
    exit(0);
}
```

## üîç Debugging avanc√©

### Tra√ßage complet des √©v√©nements

```c
// Avec ui_set_event_logging(true), vous verrez :

// Survol d'un bouton :
// [EVENT] [EventManager] [MouseMove] [menu-buttons] : Mouse at (400, 280)
// [EVENT] [AtomicElement] [MouseEnter] [play] : Element entered, bounds (260,250,280,60)
// [EVENT] [Button] [StateChange] [play] : State NORMAL -> HOVERED
// [EVENT] [UIComponent] [Hover] [play] : Hover callback triggered

// Clic sur un bouton :
// [EVENT] [EventManager] [MouseDown] [play] : Button pressed at (400, 280)
// [EVENT] [AtomicElement] [MouseDown] [play] : Hit test passed
// [EVENT] [Button] [StateChange] [play] : State HOVERED -> PRESSED
// [EVENT] [EventManager] [MouseUp] [play] : Button released at (400, 280)
// [EVENT] [UIComponent] [Click] [play] : Button click callback triggered
// [EVENT] [Button] [StateChange] [play] : State PRESSED -> HOVERED
```

### Inspection des z-index en temps r√©el

```c
// Fonction de debug pour visualiser les z-index
void debug_interface_z_index(UITree* tree) {
    printf("=== Z-INDEX DEBUG ===\n");
    
    // Parcourir tous les √©l√©ments
    ui_tree_traverse(tree->root, print_z_index, NULL);
}

void print_z_index(UINode* node, void* user_data) {
    int z = ui_node_get_effective_z_index(node);
    printf("Element '%s' : z-index = %d %s\n", 
           node->id, 
           z,
           ui_node_has_explicit_z_index(node) ? "(explicite)" : "(automatique)");
}
```

## üÜï Nouvelles fonctionnalit√©s compl√®tes

### ‚ú® Logs intelligents
- **Tra√ßage complet** de la propagation des √©v√©nements
- **Sources identifi√©es** (EventManager, AtomicElement, Button, etc.)
- **Messages descriptifs** pour debugging rapide
- **Activation/d√©sactivation** √† la vol√©e

### üéØ Z-Index automatique
- **Calcul intelligent** bas√© sur l'ordre d'ajout
- **√âl√©ments r√©cents** au premier plan automatiquement
- **Z-index explicites** prioritaires sur automatiques
- **Inspection en temps r√©el** des valeurs

### üñºÔ∏è Images PNG optimis√©es
- **Support natif** des backgrounds PNG avec transparence
- **Chargement automatique** et cache des textures
- **Redimensionnement intelligent** selon l'√©l√©ment
- **Correction des artefacts** de rendu de texte

### üîß Debugging avanc√©
- **Inspection compl√®te** de l'√©tat des √©l√©ments
- **Tra√ßage des changements** d'√©tat en temps r√©el
- **Messages color√©s** et structur√©s
- **Navigation** dans la hi√©rarchie UI

### üéâ Feedback visuel interactif
- **√âtats visuels automatiques** pour les boutons (hover, click, normal)
- **Styles pr√©d√©finis** pour actions contextuelles (succ√®s, danger, info, avertissement)
- **Logs de feedback** en temps r√©el pour chaque interaction

Cette version du syst√®me DOM-like offre maintenant tous les outils n√©cessaires pour cr√©er et d√©boguer des interfaces modernes et robustes ! üéâ
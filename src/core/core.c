#include "core.h"
#include "../utils/log_console.h"
#include <stdlib.h>
#include <stdio.h>

// === FONCTIONS DE LA BOUCLE D'√âV√âNEMENTS ===

EventLoop* event_loop_create(EventManager* event_manager) {
    EventLoop* loop = (EventLoop*)calloc(1, sizeof(EventLoop));
    if (!loop) {
        printf("‚ùå Impossible d'allouer la m√©moire pour EventLoop\n");
        return NULL;
    }
    
    // Initialiser le buffer circulaire
    loop->buffer_size = 256; // Buffer pour 256 √©v√©nements
    loop->event_buffer = (WindowEvent*)calloc(loop->buffer_size, sizeof(WindowEvent));
    if (!loop->event_buffer) {
        free(loop);
        return NULL;
    }
    
    // Cr√©er les primitives de synchronisation
    loop->event_mutex = SDL_CreateMutex();
    loop->event_condition = SDL_CreateCond();
    
    if (!loop->event_mutex || !loop->event_condition) {
        if (loop->event_mutex) SDL_DestroyMutex(loop->event_mutex);
        if (loop->event_condition) SDL_DestroyCond(loop->event_condition);
        free(loop->event_buffer);
        free(loop);
        return NULL;
    }
    
    loop->event_manager = event_manager;
    loop->running = false;
    loop->processing_events = false;
    
    log_console_write("EventLoop", "Created", "core.c", 
                     "[core.c] Event loop created with 256-event buffer");
    
    return loop;
}

void event_loop_destroy(EventLoop* loop) {
    if (!loop) return;
    
    // Arr√™ter la boucle si elle tourne
    event_loop_stop(loop);
    
    // Lib√©rer les ressources
    if (loop->event_mutex) SDL_DestroyMutex(loop->event_mutex);
    if (loop->event_condition) SDL_DestroyCond(loop->event_condition);
    free(loop->event_buffer);
    free(loop);
    
    log_console_write("EventLoop", "Destroyed", "core.c", 
                     "[core.c] Event loop destroyed");
}

bool event_loop_start(EventLoop* loop) {
    if (!loop || loop->running) return false;
    
    loop->running = true;
    loop->processing_events = true;
    
    // Cr√©er le thread d'√©v√©nements
    loop->event_thread = SDL_CreateThread(event_loop_thread_function, "EventLoop", loop);
    
    if (!loop->event_thread) {
        printf("‚ùå Impossible de cr√©er le thread d'√©v√©nements: %s\n", SDL_GetError());
        loop->running = false;
        loop->processing_events = false;
        return false;
    }
    
    log_console_write("EventLoop", "Started", "core.c", 
                     "[core.c] Event loop thread started - dedicated event processing");
    
    return true;
}

void event_loop_stop(EventLoop* loop) {
    if (!loop || !loop->running) return;
    
    log_console_write("EventLoop", "Stopping", "core.c", 
                     "[core.c] Stopping event loop thread...");
    
    // Signaler l'arr√™t
    SDL_LockMutex(loop->event_mutex);
    loop->running = false;
    loop->processing_events = false;
    SDL_CondSignal(loop->event_condition);
    SDL_UnlockMutex(loop->event_mutex);
    
    // Attendre la fin du thread
    if (loop->event_thread) {
        int thread_result;
        SDL_WaitThread(loop->event_thread, &thread_result);
        loop->event_thread = NULL;
        
        log_console_write("EventLoop", "Stopped", "core.c", 
                         "[core.c] Event loop thread stopped cleanly");
    }
}

// üÜï THREAD D√âDI√â POUR LA CAPTURE D'√âV√âNEMENTS (CORRIG√â)
int event_loop_thread_function(void* data) {
    EventLoop* loop = (EventLoop*)data;
    
    log_console_write("EventLoop", "ThreadStarted", "core.c", 
                     "[core.c] Event capture thread started");
    
    while (loop->running) {
        WindowEvent window_event;
        
        if (window_poll_events(&window_event)) {
            if (window_event.is_valid) {
                
                // üîß FIX: Classification correcte des √©v√©nements
                bool should_log = false;
                
                switch (window_event.sdl_event.type) {
                    case SDL_MOUSEBUTTONDOWN: // 1024 - VRAI CLIC
                        should_log = true;
                        break;
                    case SDL_MOUSEBUTTONUP: // 1025 - PAS UN CLIC, mais important pour UI
                        should_log = false; // üîß Ne plus logger les mouseup comme critiques
                        break;
                    case SDL_WINDOWEVENT: // 512
                        // Seulement logger les fermetures de fen√™tre
                        if (window_event.sdl_event.window.event == SDL_WINDOWEVENT_CLOSE) {
                            should_log = true;
                        }
                        break;
                    case SDL_QUIT: // 256
                        should_log = true;
                        break;
                    case SDL_MOUSEMOTION: // 1026 - NE PAS LOGGER
                        should_log = false;
                        break;
                    default: 
                        should_log = false;
                        break;
                }
                
                // üîß LOG SEULEMENT SI CRITIQUE
                if (should_log) {
                    log_console_write_event("EventLoop", "EventCaptured", "core.c", 
                                           "[core.c] Critical event captured", 
                                           window_event.sdl_event.type);
                }
                
                // Ajouter TOUS les √©v√©nements au buffer
                event_loop_push_event(loop, &window_event);
            }
        } else {
            SDL_Delay(1);
        }
        
        window_update_focus();
    }
    
    log_console_write("EventLoop", "ThreadExiting", "core.c", 
                     "[core.c] Event thread stopped");
    
    return 0;
}

// Buffer thread-safe pour les √©v√©nements
bool event_loop_push_event(EventLoop* loop, WindowEvent* event) {
    if (!loop || !event) return false;
    
    SDL_LockMutex(loop->event_mutex);
    
    // V√©rifier si le buffer est plein
    if (loop->buffer_count >= loop->buffer_size) {
        SDL_UnlockMutex(loop->event_mutex);
        return false; // Buffer plein
    }
    
    // Ajouter l'√©v√©nement au buffer
    loop->event_buffer[loop->buffer_head] = *event;
    loop->buffer_head = (loop->buffer_head + 1) % loop->buffer_size;
    loop->buffer_count++;
    
    // Signaler qu'un √©v√©nement est disponible
    SDL_CondSignal(loop->event_condition);
    
    SDL_UnlockMutex(loop->event_mutex);
    return true;
}

bool event_loop_pop_event(EventLoop* loop, WindowEvent* event) {
    if (!loop || !event) return false;
    
    SDL_LockMutex(loop->event_mutex);
    
    // V√©rifier s'il y a des √©v√©nements
    if (loop->buffer_count == 0) {
        SDL_UnlockMutex(loop->event_mutex);
        return false; // Pas d'√©v√©nement
    }
    
    // R√©cup√©rer l'√©v√©nement du buffer
    *event = loop->event_buffer[loop->buffer_tail];
    loop->buffer_tail = (loop->buffer_tail + 1) % loop->buffer_size;
    loop->buffer_count--;
    
    SDL_UnlockMutex(loop->event_mutex);
    return true;
}

// === FONCTIONS DU CORE MODIFI√âES ===

GameCore* game_core_create(void) {
    GameCore* core = (GameCore*)malloc(sizeof(GameCore));
    if (!core) {
        printf("Erreur: Impossible d'allouer la m√©moire pour le core\n");
        return NULL;
    }
    
    core->event_manager = event_manager_create();
    if (!core->event_manager) {
        free(core);
        return NULL;
    }
    
    core->scene_manager = scene_manager_create();
    if (!core->scene_manager) {
        event_manager_destroy(core->event_manager);
        free(core);
        return NULL;
    }
    
    // üÜï Cr√©er la boucle d'√©v√©nements MAIS ne pas la d√©marrer encore
    core->event_loop = event_loop_create(core->event_manager);
    if (!core->event_loop) {
        scene_manager_destroy(core->scene_manager);
        event_manager_destroy(core->event_manager);
        free(core);
        return NULL;
    }
    
    // üîß FIX: Cr√©er et INITIALISER la sc√®ne home imm√©diatement avec v√©rifications
    printf("üè† Cr√©ation de la sc√®ne home...\n");
    Scene* home_scene = create_home_scene();
    if (!home_scene) {
        printf("‚ùå Erreur: Impossible de cr√©er la sc√®ne home\n");
        event_loop_destroy(core->event_loop);
        scene_manager_destroy(core->scene_manager);
        event_manager_destroy(core->event_manager);
        free(core);
        return NULL;
    }
    
    printf("üîß D√©finition de la sc√®ne home comme sc√®ne courante...\n");
    if (!scene_manager_set_scene(core->scene_manager, home_scene)) {
        printf("‚ùå Erreur: Impossible de d√©finir la sc√®ne home\n");
        // Nettoyer la sc√®ne cr√©√©e
        if (home_scene->cleanup) home_scene->cleanup(home_scene);
        free(home_scene);
        event_loop_destroy(core->event_loop);
        scene_manager_destroy(core->scene_manager);
        event_manager_destroy(core->event_manager);
        free(core);
        return NULL;
    }
    
    // üÜï V√©rifier que la sc√®ne a √©t√© correctement d√©finie
    Scene* verification_scene = scene_manager_get_current_scene(core->scene_manager);
    if (!verification_scene) {
        printf("‚ùå Erreur: Sc√®ne non d√©finie apr√®s scene_manager_set_scene\n");
        event_loop_destroy(core->event_loop);
        scene_manager_destroy(core->scene_manager);
        event_manager_destroy(core->event_manager);
        free(core);
        return NULL;
    }
    printf("‚úÖ Sc√®ne home correctement d√©finie (nom: '%s')\n", verification_scene->name);
    
    // üÜï INITIALISER la sc√®ne imm√©diatement
    if (verification_scene->init) {
        printf("üîß Initialisation de la sc√®ne home...\n");
        verification_scene->init(verification_scene);
        
        // V√©rifier que l'initialisation a r√©ussi (donn√©es cr√©√©es)
        if (verification_scene->data) {
            printf("‚úÖ Sc√®ne home initialis√©e avec succ√®s\n");
        } else {
            printf("‚ö†Ô∏è Sc√®ne initialis√©e mais donn√©es manquantes\n");
        }
    } else {
        printf("‚ö†Ô∏è Pas de fonction d'initialisation pour la sc√®ne\n");
    }
    
    core->last_time = SDL_GetTicks();
    core->running = true;
    
    printf("‚úÖ Core cr√©√© avec sc√®ne home initialis√©e et v√©rifi√©e\n");
    
    return core;
}

// üÜï Nouvelle fonction pour finaliser l'initialisation
bool game_core_finalize_init(GameCore* core) {
    if (!core) {
        printf("‚ùå Core est NULL\n");
        return false;
    }
    
    if (!core->scene_manager) {
        printf("‚ùå Scene manager est NULL\n");
        return false;
    }
    
    // R√©cup√©ration de la sc√®ne courante
    printf("üîç R√©cup√©ration de la sc√®ne courante...\n");
    Scene* current_scene = scene_manager_get_current_scene(core->scene_manager);
    
    if (!current_scene) {
        printf("‚ùå Aucune sc√®ne courante trouv√©e\n");
        return false;
    } else {
        printf("‚úÖ Sc√®ne courante trouv√©e: '%s'\n", current_scene->name ? current_scene->name : "sans nom");
    }
    
    // Connexion des √©v√©nements
    if (current_scene->data) {
        printf("üîó Connexion des √©v√©nements de la sc√®ne '%s'...\n", current_scene->name);
        home_scene_connect_events(current_scene, core);
        printf("‚úÖ √âv√©nements de la sc√®ne connect√©s\n");
        
        // üÜï DEBUG: V√©rifier combien d'√©l√©ments sont enregistr√©s
        printf("üîç Debug: V√©rification des √©l√©ments enregistr√©s...\n");
        log_console_debug_event_manager(core->event_manager);
        
    } else {
        printf("‚ùå Sc√®ne non initialis√©e\n");
        return false;
    }
    
    // Activer le tracking souris
    log_console_set_mouse_tracking(true);
    printf("üñ±Ô∏è Tracking souris activ√©\n");
    
    // D√©marrer la boucle d'√©v√©nements
    if (!event_loop_start(core->event_loop)) {
        printf("‚ùå Impossible de d√©marrer la boucle d'√©v√©nements\n");
        return false;
    }
    
    log_console_write("EventLoop", "SystemReady", "core.c", 
                     "[core.c] Event system fully operational");
    
    printf("‚úÖ Core compl√®tement initialis√© avec boucle d'√©v√©nements active\n");
    return true;
}

void game_core_destroy(GameCore* core) {
    if (!core) return;
    
    // üÜï Arr√™ter la boucle d'√©v√©nements en premier
    if (core->event_loop) {
        event_loop_destroy(core->event_loop);
    }
    
    if (core->scene_manager) {
        scene_manager_destroy(core->scene_manager);
    }
    
    if (core->event_manager) {
        event_manager_destroy(core->event_manager);
    }
    
    free(core);
}

// üÜï NOUVELLE FONCTION : Traitement des √©v√©nements depuis le buffer (LOGS R√âDUITS)
void game_core_handle_events(GameCore* core) {
    if (!core || !core->event_loop || !core->event_manager) return;
    
    WindowEvent window_event;
    int critical_events = 0;
    
    while (event_loop_pop_event(core->event_loop, &window_event)) {
        SDL_Event* event = &window_event.sdl_event;
        
        // üîß FIX: Classification correcte des √©v√©nements
        bool is_critical = false;
        
        switch (event->type) {
            case SDL_MOUSEBUTTONDOWN: // 1024 - VRAI CLIC
                is_critical = true;
                break;
            case SDL_MOUSEBUTTONUP: // 1025 - Important pour UI mais pas critique
                is_critical = false;
                break;
            case SDL_WINDOWEVENT: // 512
                if (event->window.event == SDL_WINDOWEVENT_CLOSE) {
                    is_critical = true;
                }
                break;
            case SDL_QUIT: // 256
                is_critical = true;
                break;
            default:
                is_critical = false;
                break;
        }
        
        if (is_critical) {
            critical_events++;
            log_console_write_event("CoreEvents", "Processing", "core", 
                                   "[core.c] Processing critical event", event->type);
        }
        
        // Transmission vers Event Manager de TOUS les √©v√©nements
        event_manager_handle_event(core->event_manager, event);
        
        if (!event_manager_is_running(core->event_manager)) {
            core->running = false;
            break;
        }
    }
    
    // LOG R√âSUM√â SEULEMENT SI √âV√âNEMENTS CRITIQUES
    if (critical_events > 0) {
        char message[128];
        snprintf(message, sizeof(message), 
                "[core.c] Processed %d critical events", critical_events);
        log_console_write("CoreEvents", "Summary", "core", message);
    }
}

// V√©rifier si le jeu est en cours d'ex√©cution
bool game_core_is_running(GameCore* core) {
    return core ? core->running : false;
}

// D√©finir l'√©tat d'ex√©cution
void game_core_set_running(GameCore* core, bool running) {
    if (core) {
        core->running = running;
        if (core->event_manager) {
            event_manager_set_running(core->event_manager, running);
        }
    }
}

// Obtenir l'event manager
EventManager* game_core_get_event_manager(GameCore* core) {
    return core ? core->event_manager : NULL;
}

// Mettre √† jour le core
void game_core_update(GameCore* core) {
    if (!core || !core->scene_manager) return;
    
    // Calculer le delta time
    Uint32 current_time = SDL_GetTicks();
    float delta_time = (current_time - core->last_time) / 1000.0f;
    core->last_time = current_time;
    
    // Mettre √† jour le gestionnaire de sc√®nes
    scene_manager_update(core->scene_manager, delta_time);
}

// Rendre le core (AVEC SYNCHRONISATION AM√âLIOR√âE)
void game_core_render(GameCore* core) {
    if (!core || !core->scene_manager) return;
    
    WindowType active_type = window_get_active_window();
    
    // üîß FIX: Synchronisation stricte pour √©viter le clignotement
    switch (active_type) {
        case WINDOW_TYPE_MAIN: {
            GameWindow* main_window = use_main_window();
            if (main_window && main_window->renderer) {
                // üîß Clear avec couleur de fond coh√©rente
                SDL_SetRenderDrawColor(main_window->renderer, 135, 206, 250, 255);
                SDL_RenderClear(main_window->renderer);
                
                // Rendu de la sc√®ne (sans clear/present)
                scene_manager_render_main(core->scene_manager);
                
                // üîß Present SEULEMENT √† la fin
                SDL_RenderPresent(main_window->renderer);
            }
            break;
        }
        case WINDOW_TYPE_MINI: {
            GameWindow* mini_window = use_mini_window();
            if (mini_window && mini_window->renderer) {
                // üîß Clear avec couleur de fond coh√©rente
                SDL_SetRenderDrawColor(mini_window->renderer, 135, 206, 250, 255);
                SDL_RenderClear(mini_window->renderer);
                
                // Rendu de la sc√®ne (sans clear/present)
                scene_manager_render_mini(core->scene_manager);
                
                // üîß Present SEULEMENT √† la fin
                SDL_RenderPresent(mini_window->renderer);
            }
            break;
        }
        case WINDOW_TYPE_BOTH: {
            GameWindow* main_window = use_main_window();
            GameWindow* mini_window = use_mini_window();
            
            // üîß Rendu s√©quentiel pour √©viter les conflits
            if (main_window && main_window->renderer) {
                SDL_SetRenderDrawColor(main_window->renderer, 135, 206, 250, 255);
                SDL_RenderClear(main_window->renderer);
                scene_manager_render_main(core->scene_manager);
                SDL_RenderPresent(main_window->renderer);
            }
            
            if (mini_window && mini_window->renderer) {
                SDL_SetRenderDrawColor(mini_window->renderer, 135, 206, 250, 255);
                SDL_RenderClear(mini_window->renderer);
                scene_manager_render_mini(core->scene_manager);
                SDL_RenderPresent(mini_window->renderer);
            }
            break;
        }
    }
}

// Basculer vers la fen√™tre principale
void game_core_switch_to_main_window(GameCore* core) {
    (void)core; // √âviter l'avertissement
    printf("Basculement vers la fen√™tre principale\n");
    window_set_active_window(WINDOW_TYPE_MAIN);
}

// Basculer vers la mini fen√™tre
void game_core_switch_to_mini_window(GameCore* core) {
    (void)core; // √âviter l'avertissement
    printf("Basculement vers la mini fen√™tre\n");
    window_set_active_window(WINDOW_TYPE_MINI);
}

// Ouvrir les deux fen√™tres
void game_core_open_both_windows(GameCore* core) {
    (void)core; // √âviter l'avertissement
    printf("Ouverture des deux fen√™tres\n");
    window_set_active_window(WINDOW_TYPE_BOTH);
}

// Obtenir le type de fen√™tre active
WindowType game_core_get_active_window_type(GameCore* core) {
    (void)core; // √âviter l'avertissement
    return window_get_active_window();
}
#define _POSIX_C_SOURCE 200809L
#include "scene.h"
#include "../ui/ui_components.h"
#include "../utils/asset_manager.h"
#include "../utils/log_console.h"
#include "../ui/components/ui_link.h"  // üîß AJOUT√â: Import pour ui_create_link
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// Forward declaration pour √©viter l'include circulaire
typedef struct GameCore GameCore;
extern EventManager* game_core_get_event_manager(GameCore* core);
// Nouveau: acc√®s √† la fonction pour changer l'√©tat running
extern void game_core_set_running(GameCore* core, bool running);
// Petit stockage global pour permettre au callback du bouton d'acc√©der au core
static GameCore* s_home_scene_core = NULL;

// Donn√©es pour la sc√®ne home
typedef struct HomeSceneData {
    bool initialized;
    UITree* ui_tree;
    SDL_Texture* background_texture;
    SDL_Texture* logo_texture;
    GameCore* core;
    UINode* play_button;
    UINode* quit_button;
} HomeSceneData;

// üÜï Callbacks simplifi√©s sans d√©pendances
static void quit_button_clicked(void* element, SDL_Event* event) {
    AtomicElement* atomic_element = (AtomicElement*)element;
    
    // üéØ FEEDBACK VISUEL SIMPLIFI√â
    atomic_set_background_color(atomic_element, 220, 100, 100, 255);
    atomic_set_text_color_rgba(atomic_element, 255, 255, 255, 255);
    
    // üîß FIX: Utiliser les valeurs directes du style
    int current_width = atomic_element->style.width;
    int current_height = atomic_element->style.height;
    atomic_set_size(atomic_element, current_width - 4, current_height - 2);
    
    // üîß LOG SIMPLE
    printf("üö™ Quit button clicked with visual feedback\n");
    
    // üÜï Demander l'arr√™t propre du core si disponible
    if (s_home_scene_core) {
        game_core_set_running(s_home_scene_core, false);
        printf("üîå game_core_set_running(..., false) appel√© pour quitter proprement\n");
    } else {
        // Fallback: exit si le core n'est pas accessible
        printf("‚ö†Ô∏è Core non disponible, exit(0) en fallback\n");
        exit(0);
    }
    
    (void)event;
}

// üîß FIX: Callbacks avec gestion s√©curis√©e de la taille et effet de scale
static void button_hovered(void* element, SDL_Event* event) {
    AtomicElement* atomic_element = (AtomicElement*)element;
    
    // üÜï APPLIQUER L'EFFET DE SCALE HOVER via l'API UI
    // Cr√©er un UINode temporaire pour utiliser l'API
    UINode temp_node = {0};
    temp_node.element = atomic_element;
    temp_node.id = atomic_element->id;
    
    // Appliquer l'effet de scale hover (105%)
    ui_button_scale_hover(&temp_node);
    
    // Ajouter l'overlay lumineux
    atomic_set_background_color(atomic_element, 255, 255, 255, 30);
    
    //printf("üîç [HOVER_SCALE] Button hovered with 105%% scale effect\n");
    
    (void)event;
}

static void button_unhovered(void* element, SDL_Event* event) {
    AtomicElement* atomic_element = (AtomicElement*)element;
    
    // üÜï RETOUR √Ä LA TAILLE NORMALE via l'API UI
    UINode temp_node = {0};
    temp_node.element = atomic_element;
    temp_node.id = atomic_element->id;
    
    // Retour au scale normal (100%)
    ui_button_scale_normal(&temp_node);
    
    // Supprimer l'overlay
    atomic_set_background_color(atomic_element, 0, 0, 0, 0);
    
    //printf("üîç [UNHOVER_SCALE] Button unhovered with 100%% scale restored\n");
    
    (void)event;
}

// Fonction pour appliquer le style de bouton √† un lien
static void style_link_like_button(UINode* link) {
    if (!link || !link->element) return;
    
    // üîß FIX: Forcer la taille AVANT et APR√àS
    atomic_set_size(link->element, 150, 40);
    
    // üîß FIX: D√©sactiver le shrink pour ce bouton sp√©cifiquement
    atomic_set_flex_shrink(link->element, 0);
    
    // Configuration visuelle identique au bouton
    ui_button_set_background_image(link, "home_bg_btn.png");
    SET_BG_SIZE(link, "cover");
    SET_BG_REPEAT(link, "no-repeat");
    ui_set_text_color(link, "rgb(255, 255, 255)");
    atomic_set_padding(link->element, 10, 15, 10, 15);
    atomic_set_text_align(link->element, TEXT_ALIGN_CENTER);
    
    // üîß FIX: Re-forcer la taille apr√®s configuration
    atomic_set_size(link->element, 150, 40);
    
    printf("üîß [STYLE_LINK] Taille forc√©e √† 150x40, shrink=0\n");
}

// üÜï NOUVEAU: Callback de debug pour v√©rifier les tailles AVEC PLUS DE D√âTAILS
static void debug_element_size(AtomicElement* element, const char* context) {
    if (!element) return;
    
    printf("üîç [%s] Element '%s':\n", 
           context,
           element->id ? element->id : "NoID");
    printf("   üìê Style size: %dx%d\n", element->style.width, element->style.height);
    printf("   üìç Style pos: (%d,%d)\n", element->style.x, element->style.y);
    
    // Obtenir les diff√©rents rectangles
    SDL_Rect render_rect = atomic_get_render_rect(element);
    SDL_Rect final_rect = atomic_get_final_render_rect(element);
    SDL_Rect content_rect = atomic_get_content_rect(element);
    
    printf("   üé® Render rect: (%d,%d,%dx%d)\n", 
           render_rect.x, render_rect.y, render_rect.w, render_rect.h);
    printf("   üéØ Final rect: (%d,%d,%dx%d)\n", 
           final_rect.x, final_rect.y, final_rect.w, final_rect.h);
    printf("   üì¶ Content rect: (%d,%d,%dx%d)\n", 
           content_rect.x, content_rect.y, content_rect.w, content_rect.h);
           
    // V√©rifier si les tailles sont valides
    if (element->style.width <= 0 || element->style.height <= 0) {
        printf("‚ùå TAILLE INVALIDE D√âTECT√âE!\n");
    }
    
    // V√©rifier si les rectangles diff√®rent
    if (render_rect.w != final_rect.w || render_rect.h != final_rect.h) {
        printf("‚ö†Ô∏è DIFF√âRENCE entre render_rect et final_rect d√©tect√©e!\n");
    }
    
    printf("\n");
}

// Initialisation de la sc√®ne home
static void home_scene_init(Scene* scene) {
    printf("üè† Initialisation de la sc√®ne Home avec UI DOM-like\n");
    
    // üîß SUPPRESSION: Plus d'activation automatique de la console d'√©v√©nements
    
    // Activer les logs d'√©v√©nements pour debugging
    ui_set_event_logging(true);
    
    // Activer la visualisation des hitboxes (seulement pour home)
    ui_set_hitbox_visualization(true);
    printf("üéØ Visualisation des hitboxes activ√©e pour la sc√®ne HOME\n");
    printf("   üì± Rectangles rouges transparents avec bordure bleue 4px\n");
    printf("   üìä Logs d√©taill√©s des dimensions dans la console d'√©v√©nements\n");
    
    HomeSceneData* data = (HomeSceneData*)malloc(sizeof(HomeSceneData));
    if (!data) {
        printf("Erreur: Impossible d'allouer la m√©moire pour HomeSceneData\n");
        return;
    }
    
    data->initialized = true;
    data->background_texture = NULL;
    data->logo_texture = NULL;
    data->core = NULL; // üÜï Sera d√©fini plus tard
    data->play_button = NULL; // üÜï Initialiser √† NULL
    data->quit_button = NULL; // üÜï Initialiser √† NULL
    
    // Cr√©er l'arbre UI
    data->ui_tree = ui_tree_create();
    ui_set_global_tree(data->ui_tree);
    
    // Charger les assets
    GameWindow* window = use_mini_window();
    if (window) {
        SDL_Renderer* renderer = window_get_renderer(window);
        if (renderer) {
            // Charger les textures avec des chemins complets
            data->background_texture = asset_load_texture(renderer, "fix_bg.png");
            data->logo_texture = asset_load_texture(renderer, "fanorona_text.png");
            
            printf("üîç Chargement des assets :\n");
            printf("   Background: %s\n", data->background_texture ? "‚úÖ OK" : "‚ùå √âCHEC");
            printf("   Logo: %s\n", data->logo_texture ? "‚úÖ OK" : "‚ùå √âCHEC");
        }
    }
    
    // === CR√âATION DE L'INTERFACE ===
    
    // Container principal (plein √©cran)
    UINode* app = UI_DIV(data->ui_tree, "home-app");
    if (!app) {
        printf("‚ùå Erreur: Impossible de cr√©er le container principal\n");
        return;
    }
    
    SET_POS(app, 0, 0);
    SET_SIZE(app, 700, 500);
    
    // D√©finir l'image de fond du container principal
    if (data->background_texture) {
        atomic_set_background_image(app->element, data->background_texture);
    } else {
        SET_BG(app, "rgb(135, 206, 250)"); // Bleu ciel par d√©faut
    }
    
    // Container principal en flexbox column pour organiser verticalement
    ui_set_display_flex(app);
    FLEX_COLUMN(app);
    ui_set_justify_content(app, "center");
    ui_set_align_items(app, "center");
    ui_set_flex_gap(app, 30); // R√©duire le gap pour que les boutons restent √† l'√©cran
    
    // Logo Fanorona au centre (r√©duire la taille pour laisser place aux boutons)
    UINode* logo = UI_IMAGE(data->ui_tree, "fanorona-logo", data->logo_texture);
    if (!logo) {
        printf("‚ùå Erreur: Impossible de cr√©er le logo\n");
        return;
    }
    
    SET_SIZE(logo, 400, 150); // R√©duire la taille du logo
    
    if (data->logo_texture) {
        printf("üñºÔ∏è Logo PNG charg√© avec composant image (fond transparent)\n");
        // S'assurer que le logo n'a pas de background par d√©faut (d√©j√† transparent)
        atomic_set_background_color(logo->element, 0, 0, 0, 0); // Explicitement transparent
    } else {
        // Fallback: cr√©er un texte √† la place
        logo = UI_DIV(data->ui_tree, "fanorona-logo-fallback");
        if (logo) {
            SET_SIZE(logo, 400, 100); // Plus petit aussi
            SET_BG(logo, "rgb(255,255,255)");
            UINode* logo_text = UI_TEXT(data->ui_tree, "logo-text", "FANORONA");
            if (logo_text) {
                ui_set_text_align(logo_text, "center");
                ui_set_text_color(logo_text, "rgb(0,0,0)");
                CENTER(logo_text);
                APPEND(logo, logo_text);
            }
            printf("üìù Logo en texte de secours utilis√©\n");
        }
    }
    
    // Container pour les boutons - üîß FIX: Augmenter la taille pour √©viter le shrink
    UINode* button_container = UI_DIV(data->ui_tree, "button-container");
    if (!button_container) {
        printf("‚ùå Erreur: Impossible de cr√©er le container de boutons\n");
        return;
    }
    
    // üîß FIX: Donner une taille suffisante au container pour √©viter le flex shrink
    SET_SIZE(button_container, 300, 150); // Hauteur suffisante pour 2 boutons + gap
    
    ui_set_display_flex(button_container);
    FLEX_COLUMN(button_container);
    ui_set_justify_content(button_container, "center");
    ui_set_align_items(button_container, "center");
    ui_set_flex_gap(button_container, 20); // üîß FIX: R√©duire le gap pour √©viter l'overflow
    
    // üÜï REMPLACER LE BOUTON PLAY PAR UN UI LINK AVEC DEBUG D√âTAILL√â
    UINode* play_link = ui_create_link(data->ui_tree, "play-link", "JOUER", "menu", SCENE_TRANSITION_REPLACE);
    data->play_button = play_link; // On garde la r√©f√©rence dans play_button pour les callbacks
    
    if (play_link) {
        // üÜï DEBUG AVANT STYLE: Dimensions initiales
        printf("üîç [PLAY_LINK_DEBUG] AVANT style:\n");
        debug_element_size(play_link->element, "PLAY_LINK_INITIAL");
        
        // Appliquer le m√™me style que le bouton pr√©c√©dent
        style_link_like_button(play_link);
        
        // üÜï DEBUG APR√àS STYLE: V√©rifier que les dimensions sont correctes
        printf("üîç [PLAY_LINK_DEBUG] APR√àS style_link_like_button():\n");
        debug_element_size(play_link->element, "PLAY_LINK_STYLED");
        
        // Connecter les m√™mes √©v√©nements de hover/unhover pour l'effet visuel
        atomic_set_hover_handler(play_link->element, button_hovered);
        atomic_set_unhover_handler(play_link->element, button_unhovered);
        
        // üÜï DEBUG FINAL: √âtat final avant ajout √† la hi√©rarchie
        printf("üîç [PLAY_LINK_DEBUG] FINAL avant hi√©rarchie:\n");
        debug_element_size(play_link->element, "PLAY_LINK_FINAL");
        
        ui_log_event("UIComponent", "LinkSetup", play_link->id, "Hover and unhover handlers attached");
        printf("‚úÖ Lien UI 'Play' cr√©√© avec apparence de bouton et √©v√©nements visuels connect√©s\n");
    }
    
    // Bouton Quit - avec v√©rifications ET d√©sactivation du shrink
    UINode* quit_button = ui_button(data->ui_tree, "quit-button", "QUITTER", NULL, NULL);
    data->quit_button = quit_button;
    if (quit_button) {
        // üîß FORCER la taille AVANT les autres configurations
        atomic_set_size(quit_button->element, 150, 40);
        
        // üîß FIX: D√©sactiver le shrink pour ce bouton
        atomic_set_flex_shrink(quit_button->element, 0);
        
        // üÜï DEBUG: V√©rifier la taille apr√®s cr√©ation
        debug_element_size(quit_button->element, "AFTER_CREATION");
        
        // Configuration visuelle
        ui_button_set_background_image(quit_button, "home_bg_btn.png");
        SET_BG_SIZE(quit_button, "cover");
        SET_BG_REPEAT(quit_button, "no-repeat");
        ui_set_text_color(quit_button, "rgb(255, 255, 255)");
        ui_button_fix_text_rendering(quit_button);
        
        // üîß FIX: Re-forcer la taille apr√®s configuration
        atomic_set_size(quit_button->element, 150, 40);
        
        // üÜï DEBUG: V√©rifier la taille apr√®s configuration
        debug_element_size(quit_button->element, "AFTER_CONFIG");
        
        // Connecter les √©v√©nements
        atomic_set_click_handler(quit_button->element, quit_button_clicked);
        atomic_set_hover_handler(quit_button->element, button_hovered);
        atomic_set_unhover_handler(quit_button->element, button_unhovered);
        
        // üÜï DEBUG: V√©rifier la taille apr√®s √©v√©nements
        debug_element_size(quit_button->element, "AFTER_EVENTS");
        
        printf("‚úÖ Bouton Quit cr√©√© avec shrink=0 et taille forc√©e\n");
    }
    
    // Construire la hi√©rarchie de mani√®re s√©curis√©e
    if (data->ui_tree && data->ui_tree->root) {
        APPEND(data->ui_tree->root, app);
        APPEND(app, logo);
        APPEND(app, button_container);
        
        // Ajouter le lien UI et le bouton au container
        if (play_link) APPEND(button_container, play_link);
        if (quit_button) APPEND(button_container, quit_button);
        
        // Calculer les z-index implicites apr√®s avoir construit la hi√©rarchie
        ui_calculate_implicit_z_index(data->ui_tree);
        
    } else {
        printf("‚ùå Erreur: Arbre UI ou racine non initialis√©\n");
        return;
    }
    
    // üÜï DEBUG: V√©rifications finales APR√àS construction de la hi√©rarchie
    if (play_link) {
        printf("üîç [FINAL_DEBUG] Lien Play APR√àS hi√©rarchie:\n");
        debug_element_size(play_link->element, "PLAY_LINK_IN_HIERARCHY");
        
        // Force un update pour voir si √ßa change quelque chose
        if (data->ui_tree) {
            ui_tree_update(data->ui_tree, 0.0f);
            printf("üîç [FINAL_DEBUG] Lien Play APR√àS ui_tree_update:\n");
            debug_element_size(play_link->element, "PLAY_LINK_POST_UPDATE");
        }
    }
    
    printf("‚úÖ Interface Home cr√©√©e avec debug d√©taill√© du bouton Play\n");
    
    scene->data = data;
}

// Mise √† jour de la sc√®ne home
static void home_scene_update(Scene* scene, float delta_time) {
    if (!scene || !scene->data) return;
    
    HomeSceneData* data = (HomeSceneData*)scene->data;
    
    // Mettre √† jour l'arbre UI
    if (data->ui_tree) {
        ui_tree_update(data->ui_tree, delta_time);
    }
    
    // üÜï Mettre √† jour sp√©cifiquement le bouton play (qui est un lien)
    if (data->play_button) {
        ui_link_update(data->play_button, delta_time);
    }
    
    // NOTE: Les √©v√©nements SDL sont maintenant g√©r√©s dans la boucle principale
    // Ne pas faire SDL_PollEvent ici pour √©viter les conflits
}

// Rendu de la sc√®ne home
static void home_scene_render(Scene* scene, GameWindow* window) {
    if (!scene || !scene->data || !window) return;
    
    SDL_Renderer* renderer = window_get_renderer(window);
    if (!renderer) return;
    
    HomeSceneData* data = (HomeSceneData*)scene->data;
    
    // üîß FIX: NE PLUS FAIRE Clear ici - le core s'en charge
    // SDL_SetRenderDrawColor(renderer, 135, 206, 250, 255);
    // SDL_RenderClear(renderer);
    
    // Rendre SEULEMENT l'arbre UI
    if (data->ui_tree) {
        ui_tree_render(data->ui_tree, renderer);
    }
    
    // üîß FIX PRINCIPAL: NE PLUS FAIRE Present ici - le core s'en charge !
    // SDL_RenderPresent(renderer);
}

// Nettoyage de la sc√®ne home
static void home_scene_cleanup(Scene* scene) {
    printf("üßπ Nettoyage de la sc√®ne Home\n");
    if (!scene || !scene->data) {
        printf("‚ö†Ô∏è Scene ou scene->data est NULL, nettoyage ignor√©\n");
        return;
    }
    
    HomeSceneData* data = (HomeSceneData*)scene->data;
    
    // V√©rifier que les donn√©es sont valides
    if (!data->initialized) {
        printf("‚ö†Ô∏è HomeSceneData non initialis√©, nettoyage partiel\n");
        free(scene->data);
        scene->data = NULL;
        return;
    }
    
    // Lib√©rer les textures
    if (data->background_texture) {
        SDL_DestroyTexture(data->background_texture);
        data->background_texture = NULL;
        printf("‚úÖ Background texture lib√©r√©e\n");
    }
    if (data->logo_texture) {
        SDL_DestroyTexture(data->logo_texture);
        data->logo_texture = NULL;
        printf("‚úÖ Logo texture lib√©r√©e\n");
    }
    
    // Nettoyer l'arbre UI
    if (data->ui_tree) {
        ui_tree_destroy(data->ui_tree);
        data->ui_tree = NULL;
        printf("‚úÖ UI tree d√©truit\n");
    }
    
    // Nettoyer les polices TTF
    ui_cleanup_fonts();
    
    // R√©initialiser l'arbre global
    ui_set_global_tree(NULL);
    
    // Marquer comme non initialis√© avant de lib√©rer
    data->initialized = false;
    
    // Lib√©rer les donn√©es de la sc√®ne
    free(scene->data);
    scene->data = NULL;
    
    printf("‚úÖ Nettoyage de la sc√®ne Home termin√©\n");
}

// Cr√©er la sc√®ne home
Scene* create_home_scene(void) {
    Scene* scene = (Scene*)malloc(sizeof(Scene));
    if (!scene) {
        printf("Erreur: Impossible d'allouer la m√©moire pour la sc√®ne Home\n");
        return NULL;
    }
    
    // Nouveaux champs pour la structure Scene mise √† jour
    scene->id = "home";                   // Identifiant unique
    scene->name = "Home";                 // Nom d'affichage
    scene->target_window = WINDOW_TYPE_MAIN; // Fen√™tre cible
    scene->event_manager = NULL;          // Sera initialis√© plus tard
    scene->ui_tree = NULL;               // Sera cr√©√© dans init
    scene->initialized = false;          // Pas encore initialis√©
    scene->active = false;               // Pas encore actif
    
    // Fonctions de callback
    scene->init = home_scene_init;
    scene->update = home_scene_update;
    scene->render = home_scene_render;
    scene->cleanup = home_scene_cleanup;
    scene->data = NULL;
    
    return scene;
}

// Connexion des √©v√©nements adapt√©e √† la nouvelle architecture
void home_scene_connect_events(Scene* scene, GameCore* core) {
    if (!scene || !core) {
        printf("‚ùå Scene ou Core NULL dans home_scene_connect_events\n");
        return;
    }
    
    HomeSceneData* data = (HomeSceneData*)scene->data;
    if (!data) {
        printf("‚ùå Donn√©es de sc√®ne NULL\n");
        return;
    }
    
    // üÜï CONNECTER SP√âCIFIQUEMENT LE LIEN UI AU SCENEMANAGER
    if (data->play_button) {
        // Obtenir le SceneManager du Core
        extern SceneManager* game_core_get_scene_manager(GameCore* core);
        SceneManager* scene_manager = game_core_get_scene_manager(core);
        
        if (scene_manager) {
            // Connecter le lien UI au SceneManager pour les vraies transitions
            ui_link_connect_to_manager(data->play_button, scene_manager);
            printf("üîó UI Link 'Play' connect√© au SceneManager pour les transitions r√©elles\n");
            
            // üÜï Configurer un d√©lai de s√©curit√© (1 seconde)
            ui_link_set_activation_delay(data->play_button, 0.0f);
            printf("‚è±Ô∏è D√©lai de s√©curit√© de 1s configur√© pour le lien 'Play'\n");
        } else {
            printf("‚ùå SceneManager non disponible pour le lien UI\n");
        }
    }
    
    // Cr√©er un EventManager d√©di√© √† la sc√®ne si n√©cessaire
    if (!scene->event_manager) {
        printf("üîß Cr√©ation d'un EventManager d√©di√© pour la sc√®ne home\n");
        scene->event_manager = event_manager_create();
        if (!scene->event_manager) {
            printf("‚ùå Impossible de cr√©er l'EventManager pour la sc√®ne home\n");
            return;
        }
    }
    
    // Connecter l'EventManager √† l'UITree
    if (data->ui_tree) {
        data->ui_tree->event_manager = scene->event_manager;
        printf("üîó EventManager d√©di√© connect√© √† l'UITree\n");
        
        // Enregistrer tous les √©l√©ments UI avec des gestionnaires d'√©v√©nements
        ui_tree_register_all_events(data->ui_tree);
        
        // Stocker l'UITree dans la sc√®ne
        scene->ui_tree = data->ui_tree;
        
        printf("‚úÖ Tous les √©v√©nements connect√©s via l'UITree avec EventManager d√©di√©\n");
    } else {
        printf("‚ùå UITree est NULL\n");
        return;
    }
    
    // Stocker la r√©f√©rence du core
    data->core = core;
    s_home_scene_core = core; // üÜï Stocker le core dans le global static
    
    printf("‚úÖ Sc√®ne home pr√™te avec son propre syst√®me d'√©v√©nements\n");
}